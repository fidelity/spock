"use strict";(self.webpackChunkdocs_v_2=self.webpackChunkdocs_v_2||[]).push([[1157],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return k}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),o=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=o(e.components);return a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,p=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=o(n),k=r,m=d["".concat(p,".").concat(k)]||d[k]||u[k]||l;return n?a.createElement(m,s(s({ref:t},c),{},{components:n})):a.createElement(m,s({ref:t},c))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,s=new Array(l);s[0]=d;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var o=2;o<l;o++)s[o]=n[o];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},1699:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return p},metadata:function(){return o},toc:function(){return c},default:function(){return d}});var a=n(7462),r=n(3366),l=(n(7294),n(3905)),s=["components"],i={sidebar_label:"builder",title:"backend.builder"},p=void 0,o={unversionedId:"reference/backend/builder",id:"reference/backend/builder",isDocsHomePage:!1,title:"backend.builder",description:"Handles the building/saving of the configurations from the Spock config classes",source:"@site/docs/reference/backend/builder.md",sourceDirName:"reference/backend",slug:"/reference/backend/builder",permalink:"/spock/reference/backend/builder",editUrl:"https://github.com/fidelity/spock/edit/master/website/docs/reference/backend/builder.md",tags:[],version:"current",frontMatter:{sidebar_label:"builder",title:"backend.builder"},sidebar:"api",previous:{title:"args",permalink:"/spock/reference/args"},next:{title:"config",permalink:"/spock/reference/backend/config"}},c=[{value:"BaseBuilder Objects",id:"basebuilder-objects",children:[]},{value:"AttrBuilder Objects",id:"attrbuilder-objects",children:[]}],u={toc:c};function d(e){var t=e.components,n=(0,r.Z)(e,s);return(0,l.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Handles the building/saving of the configurations from the Spock config classes"),(0,l.kt)("h2",{id:"basebuilder-objects"},"BaseBuilder Objects"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"class BaseBuilder(ABC)\n")),(0,l.kt)("p",null,"Base class for building the backend specific builders"),(0,l.kt)("p",null,"This class handles the interface to the backend with the generic ConfigArgBuilder\nso that different backends can be used to handle processing"),(0,l.kt)("p",null,"Attributes"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"_input_classes: list of input classes that link to a backend\n_graph: Graph, graph of the dependencies between spock classes\n_max_indent: maximum to indent between help prints\n_module_name: module name to register in the spock module space\nsave_path: list of path(s) to save the configs to\n_lazy: attempts to lazily find @spock decorated classes registered within\nsys.modules[&quot;spock&quot;].backend.config\n_salt: salt use for crypto purposes\n_key: key used for crypto purposes\n")),(0,l.kt)("h4",{id:"__init__"},"_","_","init","_","_"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def __init__(*args, *, max_indent: int = 4, module_name: str, lazy: bool, salt: str, key: ByteString, **kwargs, ,)\n")),(0,l.kt)("p",null,"Init call for BaseBuilder"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"*args")," - iterable of @spock decorated classes"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"max_indent")," - max indent for pretty print of help"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"module_name")," - module name to register in the spock module space"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"lazy")," - lazily find @spock decorated classes"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"salt")," - cryptographic salt"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"key")," - cryptographic key"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"**kwargs")," - keyword args")),(0,l.kt)("h4",{id:"input_classes"},"input","_","classes"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef input_classes()\n")),(0,l.kt)("p",null,"Returns the graph of dependencies between spock classes"),(0,l.kt)("h4",{id:"dag"},"dag"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef dag()\n")),(0,l.kt)("p",null,"Returns the underlying graph DAG"),(0,l.kt)("h4",{id:"graph"},"graph"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@property\ndef graph()\n")),(0,l.kt)("p",null,"Returns the underlying graph object"),(0,l.kt)("h4",{id:"_make_group_override_parser"},"_","make","_","group","_","override","_","parser"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@staticmethod\n@abstractmethod\ndef _make_group_override_parser(parser: argparse.ArgumentParser, class_obj: _C, class_name: str) -> argparse.ArgumentParser\n")),(0,l.kt)("p",null,"Makes a name specific override parser for a given class obj"),(0,l.kt)("p",null,"Takes a class object of the backend and adds a new argument group with argument names given with name\nClass.name so that individual parameters specific to a class can be overridden."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"parser")," - argument parser"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"class_obj")," - instance of a backend class"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"class_name")," - used for module matching")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"parser")," - argument parser with new class specific overrides")),(0,l.kt)("h4",{id:"handle_help_info"},"handle","_","help","_","info"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def handle_help_info() -> None\n")),(0,l.kt)("p",null,"Handles walking through classes to get help info"),(0,l.kt)("p",null,"For each class this function will search ",(0,l.kt)("strong",{parentName:"p"},"doc")," and attempt to pull out help information for both the class\nitself and each attribute within the class"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("p",null,"  None"),(0,l.kt)("h4",{id:"generate"},"generate"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def generate(dict_args: Dict) -> Spockspace\n")),(0,l.kt)("p",null,"Method to auto-generate the actual class instances from the generated args"),(0,l.kt)("p",null,"Based on the generated arguments groups and the args read in from the config file(s)\nthis function instantiates the classes with the necessary field or attr values"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"dict_args")," - dictionary of arguments from the configs")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("p",null,"  namespace containing automatically generated instances of the classes"),(0,l.kt)("h4",{id:"resolve_spock_space_kwargs"},"resolve","_","spock","_","space","_","kwargs"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def resolve_spock_space_kwargs(graph: Graph, dict_args: Dict) -> Dict\n")),(0,l.kt)("p",null,"Build the dictionary that will define the spock space."),(0,l.kt)("p",null,"This is essentially the meat of the builder. Handles both the cls dep graph\nand the ref def graph. Based on that merge of the two dependency graphs\nit cal traverse the dep structure correct to resolve both cls references and\nvar refs"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"graph")," - Dependency graph of nested spock configurations"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"dict_args")," - dictionary of arguments from the configs")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("p",null,"  dictionary containing automatically generated instances of the classes"),(0,l.kt)("h4",{id:"_cast_all_maps"},"_","cast","_","all","_","maps"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@staticmethod\ndef _cast_all_maps(cls, cls_fields: Dict, changed_vars: Set) -> None\n")),(0,l.kt)("p",null,"Casts all the resolved references to the requested type"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"cls")," - current spock class"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"cls_fields")," - current fields dictionary to attempt cast within"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"changed_vars")," - set of resolved variables that need to be cast")),(0,l.kt)("h4",{id:"_clean_up_cls_refs"},"_","clean","_","up","_","cls","_","refs"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@staticmethod\ndef _clean_up_cls_refs(fields: Dict, spock_space: Dict) -> Dict\n")),(0,l.kt)("p",null,"Swaps in the newly created cls if it hasn","'","t been instantiated yet"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"fields")," - current field dictionary"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"spock_space")," - current spock space dictionary")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("p",null,"  updated fields dictionary"),(0,l.kt)("h4",{id:"build_override_parsers"},"build","_","override","_","parsers"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def build_override_parsers(parser: argparse.ArgumentParser) -> argparse.ArgumentParser\n")),(0,l.kt)("p",null,"Creates parsers for command-line overrides"),(0,l.kt)("p",null,"Builds the basic command line parser for configs and help then iterates through each attr instance to make\nnamespace specific cmd line override parsers"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"parser")," - argument parser")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"parser")," - argument parser with new class specific overrides")),(0,l.kt)("h4",{id:"_extract_other_types"},"_","extract","_","other","_","types"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def _extract_other_types(typed: _T, module_name: str) -> List\n")),(0,l.kt)("p",null,"Takes a high level type and recursively extracts any enum or class types"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"typed")," - highest level type"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"module_name")," - name of module to match")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"return_list")," - list of nums (dot notation of module_path.enum_name or module_path.class_name)")),(0,l.kt)("h4",{id:"_extract_fnc"},"_","extract","_","fnc"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@abstractmethod\ndef _extract_fnc(val, module_name)\n")),(0,l.kt)("p",null,"Function that gets the nested lists within classes"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"val")," - current attr"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"module_name")," - matching module name")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("p",null,"  list of any nested classes/enums"),(0,l.kt)("h2",{id:"attrbuilder-objects"},"AttrBuilder Objects"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"class AttrBuilder(BaseBuilder)\n")),(0,l.kt)("p",null,"Attr specific builder"),(0,l.kt)("p",null,"Class that handles building for the attr backend"),(0,l.kt)("p",null,"Attributes"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"input_classes: list of input classes that link to a backend\n_configs: None or List of configs to read from\n_create_save_path: boolean to make the path to save to\n_desc: description for the arg parser\n_no_cmd_line: flag to force no command line reads\nsave_path: list of path(s) to save the configs to\n")),(0,l.kt)("h4",{id:"__init__-1"},"_","_","init","_","_"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def __init__(*args, **kwargs)\n")),(0,l.kt)("p",null,"AttrBuilder init"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"*args")," - list of input classes that link to a backend"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"**kwargs")," - any extra keyword args")),(0,l.kt)("h4",{id:"_make_group_override_parser-1"},"_","make","_","group","_","override","_","parser"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@staticmethod\ndef _make_group_override_parser(parser: argparse.ArgumentParser, class_obj: _C, class_name: str) -> argparse.ArgumentParser\n")),(0,l.kt)("p",null,"Makes a name specific override parser for a given class obj"),(0,l.kt)("p",null,"Takes a class object of the backend and adds a new argument group with argument names given with name\nClass.name so that individual parameters specific to a class can be overridden."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"parser")," - argument parser"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"class_obj")," - instance of a backend class"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"class_name")," - used for module matching")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"parser")," - argument parser with new class specific overrides")),(0,l.kt)("h4",{id:"_extract_fnc-1"},"_","extract","_","fnc"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def _extract_fnc(val, module_name)\n")),(0,l.kt)("p",null,"Function that gets the nested lists within classes"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"val")," - current attr"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"module_name")," - matching module name")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("p",null,"  list of any nested classes/enums"))}d.isMDXComponent=!0}}]);