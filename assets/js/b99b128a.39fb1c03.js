"use strict";(self.webpackChunkdocs_v_2=self.webpackChunkdocs_v_2||[]).push([[1957],{3905:function(e,t,n){n.d(t,{Zo:function(){return o},kt:function(){return d}});var l=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);t&&(l=l.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,l)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,l,a=function(e,t){if(null==e)return{};var n,l,a={},r=Object.keys(e);for(l=0;l<r.length;l++)n=r[l],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(l=0;l<r.length;l++)n=r[l],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=l.createContext({}),u=function(e){var t=l.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},o=function(e){var t=u(e.components);return l.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return l.createElement(l.Fragment,{},t)}},k=l.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,o=p(e,["components","mdxType","originalType","parentName"]),k=u(n),d=a,m=k["".concat(s,".").concat(d)]||k[d]||c[d]||r;return n?l.createElement(m,i(i({ref:t},o),{},{components:n})):l.createElement(m,i({ref:t},o))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=k;var p={};for(var s in t)hasOwnProperty.call(t,s)&&(p[s]=t[s]);p.originalType=e,p.mdxType="string"==typeof e?e:a,i[1]=p;for(var u=2;u<r;u++)i[u]=n[u];return l.createElement.apply(null,i)}return l.createElement.apply(null,n)}k.displayName="MDXCreateElement"},8676:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return p},contentTitle:function(){return s},metadata:function(){return u},toc:function(){return o},default:function(){return k}});var l=n(7462),a=n(3366),r=(n(7294),n(3905)),i=["components"],p={sidebar_label:"utils",title:"backend.utils"},s=void 0,u={unversionedId:"reference/backend/utils",id:"reference/backend/utils",isDocsHomePage:!1,title:"backend.utils",description:"Attr utility functions for Spock",source:"@site/docs/reference/backend/utils.md",sourceDirName:"reference/backend",slug:"/reference/backend/utils",permalink:"/spock/reference/backend/utils",editUrl:"https://github.com/fidelity/spock/edit/master/website/docs/reference/backend/utils.md",tags:[],version:"current",frontMatter:{sidebar_label:"utils",title:"backend.utils"},sidebar:"api",previous:{title:"typed",permalink:"/spock/reference/backend/typed"},next:{title:"validators",permalink:"/spock/reference/backend/validators"}},o=[],c={toc:o};function k(e){var t=e.components,n=(0,a.Z)(e,i);return(0,r.kt)("wrapper",(0,l.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Attr utility functions for Spock"),(0,r.kt)("h4",{id:"encrypt_value"},"encrypt","_","value"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def encrypt_value(value: Any, key: Union[str, ByteString, bytes], salt: str)\n")),(0,r.kt)("p",null,"Encrypts a given value with a key and salt"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value")," - current value to encrypt"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"key")," - A URL-safe base64-encoded 32-byte key."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"salt")," - salt to add to value")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  encrypted value"),(0,r.kt)("h4",{id:"decrypt_value"},"decrypt","_","value"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def decrypt_value(value: Any, key: Union[str, ByteString, bytes], salt: str)\n")),(0,r.kt)("p",null,"Decrypts a given value from a key and salt"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value")," - current value to decrypt"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"key")," - A URL-safe base64-encoded 32-byte key."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"salt")," - salt to add to value")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  decrypted value"),(0,r.kt)("h4",{id:"_str_2_callable"},"_","str","_","2","_","callable"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def _str_2_callable(val: str, **kwargs)\n")),(0,r.kt)("p",null,"Tries to convert a string representation of a module and callable to the reference to the callable"),(0,r.kt)("p",null,"If the module of callable cannot be found on the PYTHONPATH then an exception is raised"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"val")," - string rep of a module and callable"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"**kwargs")," - in case additional keyword args are passed")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  reference to a callable"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Raises"),":"),(0,r.kt)("p",null,"  _SpockValueError"),(0,r.kt)("h4",{id:"_callable_2_str"},"_","callable","_","2","_","str"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def _callable_2_str(val: Callable, **kwargs)\n")),(0,r.kt)("p",null,"Converts a callable to a str based on the module and name"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"val")," - callable object"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"**kwargs")," - in case additional keyword args are passed")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  string of module.name"),(0,r.kt)("h4",{id:"_recurse_callables"},"_","recurse","_","callables"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def _recurse_callables(val: _T, fnc: Callable, check_type: Type = str)\n")),(0,r.kt)("p",null,"Recurses through objects casting any callables to the correct format"),(0,r.kt)("p",null,"Handles both strings to callables and callables to strings depending on the function passed in"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"val")," - current object"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fnc")," - callable"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"check_type")," - type to check against to verify conversion")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  object with mapped callables/strings"),(0,r.kt)("h4",{id:"_get_name_py_version"},"_","get","_","name","_","py","_","version"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def _get_name_py_version(typed: _T)\n")),(0,r.kt)("p",null,"Gets the name of the type depending on the python version"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"typed")," - the type of the parameter")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  name of the type"),(0,r.kt)("h4",{id:"get_attr_fields"},"get","_","attr","_","fields"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def get_attr_fields(input_classes: List)\n")),(0,r.kt)("p",null,"Gets the attribute fields from all classes"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"input_classes")," - current list of input classes")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  dictionary of all attrs attribute fields"),(0,r.kt)("h4",{id:"get_type_fields"},"get","_","type","_","fields"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def get_type_fields(input_classes: List)\n")),(0,r.kt)("p",null,"Creates a dictionary of names and types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"input_classes")," - list of input classes")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"type_fields")," - dictionary of names and types")),(0,r.kt)("h4",{id:"flatten_type_dict"},"flatten","_","type","_","dict"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def flatten_type_dict(type_dict: Dict)\n")),(0,r.kt)("p",null,"Flattens a nested dictionary"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"type_dict")," - dictionary of types that are generic")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"flat_dict")," - flatten dictionary to a single level")),(0,r.kt)("h4",{id:"_get_iter"},"_","get","_","iter"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def _get_iter(value: Union[List, Dict])\n")),(0,r.kt)("p",null,"Returns the iterator for the type"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value")," - instance of type List or Dict")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  iterator"),(0,r.kt)("h4",{id:"convert_to_tuples"},"convert","_","to","_","tuples"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def convert_to_tuples(input_dict: Dict, base_type_dict: Dict, flat_type_dict: Dict, class_names: List)\n")),(0,r.kt)("p",null,"Convert lists to tuples"),(0,r.kt)("p",null,"Payloads from markup come in as Lists and not Tuples. This function turns lists in to tuples for the payloads\nso the attr values are set correctly. Will call itself recursively if it is iterable. Handles list of classes\nspecifically"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"input_dict")," - input dictionary"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"base_type_dict")," - dictionary of nested types"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"flat_type_dict")," - dictionary of names with generic types"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"class_names")," - List of base spock class names")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"updated_dict")," - a dictionary with lists converted to tuples")),(0,r.kt)("h4",{id:"deep_update"},"deep","_","update"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def deep_update(source: Dict, updates: Dict)\n")),(0,r.kt)("p",null,"Deeply updates a dictionary"),(0,r.kt)("p",null,"Iterates through a dictionary recursively to update individual values within a possibly nested dictionary\nof dictionaries"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"source")," - source dictionary"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"updates")," - updates to the dictionary")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"source")," - updated version of the source dictionary")),(0,r.kt)("h4",{id:"_recursive_list_to_tuple"},"_","recursive","_","list","_","to","_","tuple"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def _recursive_list_to_tuple(key: str, value: Any, typed: _T, class_names: List)\n")),(0,r.kt)("p",null,"Recursively turn lists into tuples"),(0,r.kt)("p",null,"Recursively looks through a pair of value and type and sets any of the possibly nested type of value to tuple\nif tuple is the specified type"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"key")," - name of parameter"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value")," - value to check and set type if necessary"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"typed")," - type of the generic alias to check against"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"class_names")," - list of all spock class names")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value")," - updated value with correct type casts")))}k.isMDXComponent=!0}}]);