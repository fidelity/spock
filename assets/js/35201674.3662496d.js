"use strict";(self.webpackChunkdocs_v_2=self.webpackChunkdocs_v_2||[]).push([[952],{3905:function(e,t,a){a.d(t,{Zo:function(){return c},kt:function(){return d}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},k=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),k=p(a),d=r,m=k["".concat(o,".").concat(d)]||k[d]||u[d]||l;return a?n.createElement(m,i(i({ref:t},c),{},{components:a})):n.createElement(m,i({ref:t},c))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=k;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var p=2;p<l;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}k.displayName="MDXCreateElement"},6493:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return s},contentTitle:function(){return o},metadata:function(){return p},toc:function(){return c},default:function(){return k}});var n=a(7462),r=a(3366),l=(a(7294),a(3905)),i=["components"],s={sidebar_label:"validators",title:"backend.validators"},o=void 0,p={unversionedId:"reference/backend/validators",id:"reference/backend/validators",isDocsHomePage:!1,title:"backend.validators",description:"Handles custom attr validators",source:"@site/docs/reference/backend/validators.md",sourceDirName:"reference/backend",slug:"/reference/backend/validators",permalink:"/spock/reference/backend/validators",editUrl:"https://github.com/fidelity/spock/edit/master/website/docs/reference/backend/validators.md",tags:[],version:"current",frontMatter:{sidebar_label:"validators",title:"backend.validators"},sidebar:"api",previous:{title:"utils",permalink:"/spock/reference/backend/utils"},next:{title:"wrappers",permalink:"/spock/reference/backend/wrappers"}},c=[{value:"_IsFileValidator Objects",id:"_isfilevalidator-objects",children:[]},{value:"_IsDirectoryValidator Objects",id:"_isdirectoryvalidator-objects",children:[]},{value:"_InstanceOfValidator Objects",id:"_instanceofvalidator-objects",children:[]},{value:"_IsLenValidator Objects",id:"_islenvalidator-objects",children:[]},{value:"_OrderedIsInstanceDeepIterable Objects",id:"_orderedisinstancedeepiterable-objects",children:[]}],u={toc:c};function k(e){var t=e.components,a=(0,r.Z)(e,i);return(0,l.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Handles custom attr validators"),(0,l.kt)("h4",{id:"_check_instance"},"_","check","_","instance"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def _check_instance(value: Any, name: str, type: type) -> None\n")),(0,l.kt)("p",null,"Mimics instance_of validator from attrs library"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value")," - current value"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"name")," - attribute name"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"type")," - type to test against")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Raises"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"TypeError")," - if instance is not of the correct type")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("p",null,"  None"),(0,l.kt)("h4",{id:"_is_file"},"_","is","_","file"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def _is_file(type: _T, check_access: bool, attr: attr.Attribute, value: str) -> None\n")),(0,l.kt)("p",null,"Checks to verify that a file exists and if flagged that there are correct\npermissions on the file"),(0,l.kt)("p",null,"Private version of the method"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"type")," - type to test against"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"check_access")," - checks if r/w on file"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"attr")," - current attribute being validated"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value")," - current value trying to be set as the attribute")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Raises"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ValueError")," - If the file path is not a valid file"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"PermissionError")," - If the file does not have r/w permissions")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("p",null,"  None"),(0,l.kt)("h2",{id:"_isfilevalidator-objects"},"_","IsFileValidator Objects"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@attr.attrs(repr=False, slots=True, hash=True)\nclass _IsFileValidator()\n")),(0,l.kt)("p",null,"Attr style validator for checking if a path is a file"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Attributes"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"type")," - current type to check against"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"check_access")," - flag to check r/w permissions")),(0,l.kt)("h4",{id:"__call__"},"_","_","call","_","_"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def __call__(inst: _C, attr: attr.Attribute, value: str) -> None\n")),(0,l.kt)("p",null,"Overloading call method"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"inst")," - current class object being built"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"attr")," - current attribute being validated"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value")," - current value trying to be set as the attribute")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("p",null,"  None"),(0,l.kt)("h4",{id:"is_file"},"is","_","file"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def is_file(type: _T, check_access: bool = True) -> _IsFileValidator\n")),(0,l.kt)("p",null,"A validator that raises exceptions if the file path isn","'","t a valid file or if\nmissing correct r/w privs"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"type")," - current type to check against"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"check_access")," - flag to check r/w permissions")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("p",null,"  _IsFileValidator object"),(0,l.kt)("h4",{id:"_is_directory"},"_","is","_","directory"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def _is_directory(type: _T, create: bool, check_access: bool, attr: attr.Attribute, value: str) -> None\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"type")," - type to test against\ncreate:"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"check_access")," - checks if r/w on directory"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"attr")," - current attribute being validated"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value")," - current value trying to be set as the attribute")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Raises"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ValueError")," - if the given path isn","'","t a directory"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"PermissionError")," - if the given path cannot be created or if missing the\ncorrect r/w permissions")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("p",null,"  None"),(0,l.kt)("h2",{id:"_isdirectoryvalidator-objects"},"_","IsDirectoryValidator Objects"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@attr.attrs(repr=False, slots=True, hash=True)\nclass _IsDirectoryValidator()\n")),(0,l.kt)("p",null,"Attr style validator for checking if a path is a directory"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Attributes"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"type")," - current type to check against"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"create")," - flag to attempt to create directory if it doesn","'","t exist"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"check_access")," - flag to check r/w permissions")),(0,l.kt)("h4",{id:"__call__-1"},"_","_","call","_","_"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def __call__(inst: _C, attr: attr.Attribute, value: str) -> None\n")),(0,l.kt)("p",null,"Overloading call method"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"inst")," - current class object being built"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"attr")," - current attribute being validated"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value")," - current value trying to be set as the attribute")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("p",null,"  None"),(0,l.kt)("h4",{id:"is_directory"},"is","_","directory"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def is_directory(type: _T, create: bool = True, check_access: bool = True) -> _IsDirectoryValidator\n")),(0,l.kt)("p",null,"A validator that raises exceptions if the path isn","'","t a valid directory, if\nmissing correct r/w privs, or if the directory cannot be created"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"type")," - current type to check against"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"create")," - flag to attempt to create directory if it doesn","'","t exist"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"check_access")," - flag to check r/w permissions")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("p",null,"  _IsDirectoryValidator object"),(0,l.kt)("h2",{id:"_instanceofvalidator-objects"},"_","InstanceOfValidator Objects"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@attr.attrs(repr=False, slots=True, hash=True)\nclass _InstanceOfValidator()\n")),(0,l.kt)("p",null,"Attr style validator for handling instance checks"),(0,l.kt)("p",null,"This handles the underlying new types (directory and path) that type check\nin a different manner than normal -- thus we essentially shim the underlying attr\nvalidator with our own to catch the extra cases we need to"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Attributes"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"type")," - current type to check against")),(0,l.kt)("h4",{id:"__call__-2"},"_","_","call","_","_"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def __call__(inst: _C, attr: attr.Attribute, value: Any) -> None\n")),(0,l.kt)("p",null,"Overloading call method"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"inst")," - current class object being built"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"attr")," - current attribute being validated"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value")," - current value trying to be set as the attribute")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("p",null,"  None"),(0,l.kt)("h4",{id:"instance_of"},"instance","_","of"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def instance_of(type: _T) -> _InstanceOfValidator\n")),(0,l.kt)("p",null,"A validator that verifies that the type is correct"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"type")," - current type to check against")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("p",null,"  class of _InstanceOfValidator"),(0,l.kt)("h2",{id:"_islenvalidator-objects"},"_","IsLenValidator Objects"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@attr.attrs(repr=False, slots=True, hash=True)\nclass _IsLenValidator()\n")),(0,l.kt)("p",null,"Attr style validator for handling exact length checks"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Attributes"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"length")," - length value to check against")),(0,l.kt)("h4",{id:"__call__-3"},"_","_","call","_","_"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def __call__(inst: _C, attr: attr.Attribute, value: Union[List, Tuple]) -> None\n")),(0,l.kt)("p",null,"Overloading call method"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"inst")," - current class object being built"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"attr")," - current attribute being validated"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value")," - current value trying to be set as the attribute")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("p",null,"  None"),(0,l.kt)("h4",{id:"is_len"},"is","_","len"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def is_len(length: int)\n")),(0,l.kt)("p",null,"A validator that makes sure the input length matches what was specified"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"length")," - length value to check against")),(0,l.kt)("h2",{id:"_orderedisinstancedeepiterable-objects"},"_","OrderedIsInstanceDeepIterable Objects"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@attr.attrs(repr=False, slots=True, hash=True)\nclass _OrderedIsInstanceDeepIterable()\n")),(0,l.kt)("p",null,"Attr style validator for handling instance checks in a deep iterable that is\nordered"),(0,l.kt)("p",null,"This handles creating instance validators for deep iterables that have an ordered\nnature -- mainly tuples. Since we need to march in the correct order of the given\ntypes we have to overload the IsInstance class with new one that handles recursing\non its own"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Attributes"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ordered_types")," - ordered iterator of the requested types"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"recurse_callable")," - callable function that allows for recursing to create\nvalidators in the deep iterable object"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"iterable_validator")," - validator on the iterable")),(0,l.kt)("h4",{id:"__call__-4"},"_","_","call","_","_"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def __call__(inst: _C, attr: attr.Attribute, value: Union[List[Type], Tuple[Type, ...]])\n")),(0,l.kt)("p",null,"Overloading call method"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"inst")," - current class object being built"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"attr")," - current attribute being validated"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value")," - current value trying to be set as the attribute")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("p",null,"  None"),(0,l.kt)("h4",{id:"ordered_is_instance_deep_iterable"},"ordered","_","is","_","instance","_","deep","_","iterable"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def ordered_is_instance_deep_iterable(ordered_types: Tuple[Type, ...], recurse_callable, iterable_validator)\n")),(0,l.kt)("p",null,"A validator that makes sure the deep iterable matches the requested types in the\ngiven order"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ordered_types")," - ordered iterator of the requested types"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"recurse_callable")," - callable function that allows for recursing to create\nvalidators in the deep iterable object"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"iterable_validator")," - validator on the iterable")),(0,l.kt)("h4",{id:"_in_type"},"_","in","_","type"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def _in_type(instance, attribute, value, options)\n")),(0,l.kt)("p",null,"attrs validator for class type enum"),(0,l.kt)("p",null,"Checks if the type of the class (e.g. value) is in the specified set of types\nprovided. Also checks if the value\nis specified via the Enum definition"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"instance")," - current object instance"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"attribute")," - current attribute instance"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value")," - current value trying to be set in the attrs instance"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"options")," - list, tuple, or enum of allowed options")))}k.isMDXComponent=!0}}]);